<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pullit 온보딩 가이드</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #212529;
        }

        .top-nav {
            background-color: #343a40;
            color: #fff;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .top-nav h1 {
            font-size: 1.2rem;
            margin: 0;
            position: absolute;
            left: 2rem;
            top: 50%;
            transform: translateY(-50%);
        }

        .nav-menu {
            display: flex;
        }

        .nav-item {
            position: relative;
        }

        .nav-link, .dropdown-toggle {
            color: #dee2e6;
            text-decoration: none;
            padding: 1.5rem 1rem;
            display: block;
            background: none;
            border: none;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .nav-link:hover, .dropdown-toggle:hover {
            background-color: #495057;
            color: #fff;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: #343a40;
            min-width: 220px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1;
            list-style: none;
            padding: 0.5rem 0;
            border-radius: 0 0 5px 5px;
        }
        
        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 0.7rem 1.2rem;
            color: #dee2e6;
            display: block;
            text-decoration: none;
        }
        
        .dropdown-item:hover {
            background-color: #495057;
            color: #fff;
        }

        .main-content {
            padding: 7rem 3rem 3rem 3rem; /* top padding for fixed nav */
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            box-sizing: border-box;
        }

        .content-section {
            display: none;
            animation: fadeIn 0.5s;
        }
        .content-section.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .card {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        h3 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: #343a40;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 0.5rem;
        }
        h4 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #495057;
        }
        p, li {
            color: #495057;
        }
        code {
            background-color: #e9ecef;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 3px;
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        pre {
            background-color: #212529;
            color: #f8f9fa;
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 0.8rem;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        blockquote {
            border-left: 4px solid #adb5bd;
            padding-left: 1rem;
            margin: 1.5rem 0;
            color: #6c757d;
        }
        .floating-controls {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1001;
            background: #fff;
            padding: 0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            overflow: hidden;
            width: 220px;
        }
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1rem;
            cursor: pointer;
            background-color: #f8f9fa;
        }
        .controls-header h3 {
            margin: 0;
            font-size: 0.9rem;
            color: #495057;
        }
        #toggle-controls {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            line-height: 1;
            padding: 0;
        }
        .controls-content {
            padding: 1rem;
            border-top: 1px solid #eee;
        }
        .controls-content.hidden {
            display: none;
        }
        .floating-controls a {
            display: block;
            text-decoration: none;
            color: #007bff;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="floating-controls">
        <div class="controls-header">
            <h3>빠른 이동</h3>
            <button id="toggle-controls">🔼</button>
        </div>
        <div class="controls-content">
            <a href="/redoc.html">📄 API 문서 바로가기</a>
        </div>
    </div>
    <nav class="top-nav">
        <h1>Pullit 온보딩 가이드</h1>
        <div class="nav-menu">
            
            <div class="nav-item">
                <button class="dropdown-toggle">🚀 개요</button>
                <div class="dropdown-menu">
                    <a href="#introduction" class="nav-link dropdown-item">문서 개요</a>
                    <a href="#philosophy" class="nav-link dropdown-item">개발 철학</a>
                    <a href="#maintainers" class="nav-link dropdown-item">Maintainers</a>
                </div>
            </div>

            <div class="nav-item">
                <button class="dropdown-toggle">🛠️ 개발 프로세스</button>
                <div class="dropdown-menu">
                    <a href="#git-convention" class="nav-link dropdown-item">Git 컨벤션</a>
                    <a href="#api-design" class="nav-link dropdown-item">API 설계</a>
                </div>
            </div>
            
            <div class="nav-item">
                <button class="dropdown-toggle">🚀 배포 프로세스</button>
                <div class="dropdown-menu">
                    <a href="#deploy-overview" class="nav-link dropdown-item">배포 개요</a>
                    <a href="#deploy-ec2-setup" class="nav-link dropdown-item">1. EC2 서버 설정</a>
                    <a href="#deploy-docker-build" class="nav-link dropdown-item">2. Docker 빌드 전략</a>
                    <a href="#deploy-docker-compose" class="nav-link dropdown-item">3. EC2 컨테이너 실행</a>
                    <a href="#deploy-dns" class="nav-link dropdown-item">4. DNS 및 도메인 연결</a>
                    <a href="#deploy-nginx" class="nav-link dropdown-item">5. Nginx 리버스 프록시</a>
                    <a href="#deploy-https" class="nav-link dropdown-item">6. HTTPS 적용</a>
                </div>
            </div>

            <div class="nav-item">
                <button class="dropdown-toggle">📜 기술 표준</button>
                <div class="dropdown-menu">
                    <a href="#code-convention" class="nav-link dropdown-item">코딩 컨벤션</a>
                    <a href="#environment-setup" class="nav-link dropdown-item">개발 환경 설정</a>
                </div>
            </div>

            <div class="nav-item">
                <button class="dropdown-toggle">📚 팀 리소스</button>
                <div class="dropdown-menu">
                     <a href="#team-resources" class="nav-link dropdown-item">팀 프로젝트 페이지</a>
                </div>
            </div>
        </div>
    </nav>

    <main class="main-content">
        <section id="introduction" class="content-section active">
            <div class="card">
                <h3>👋 환영합니다!</h3>
                <blockquote>본 문서는 프로젝트의 모든 팀원이 공통으로 준수해야 할 핵심 개발 원칙과 협업 절차를 정의한다. 프론트엔드 및 백엔드 개발자는 각 파트의 상세 가이드를 추가로 숙지해야 한다.</blockquote>
                <p>Pullit 팀에 오신 것을 환영합니다! 이 문서는 새로운 팀원들이 우리 팀의 문화, 개발 프로세스, 기술 표준을 빠르고 쉽게 이해할 수 있도록 돕기 위해 만들어졌습니다. 왼쪽 메뉴를 통해 Pullit의 일하는 방식을 알아보세요.</p>
            </div>
        </section>

        <section id="philosophy" class="content-section">
            <div class="card">
                <h3>개발 철학: 모든 행위에는 의도가 있어야 한다</h3>
                <p>우리 팀의 가장 중요한 개발 철학은 <strong>"모든 행위에 의도가 있어야 한다"</strong>는 것입니다.</p>
                <p>이 철학은 특히 Git 커밋 전략에 직접적으로 적용됩니다. 우리는 <code>feat</code>, <code>fix</code>, <code>docs</code>와 같이 단순히 작업의 유형을 나타내는 커밋 메시지 컨벤션을 사용하지 않습니다. 왜냐하면 "나중에 feat 커밋만 모아보거나, fix 커밋만 따로 볼 일이 있을까?"라는 질문에 "아니오"라고 답했기 때문입니다.</p>
                <p>대신, 우리의 모든 커밋은 <strong>추적 가능한 '요구사항'에 대한 결과물</strong>이어야 합니다. 과거의 코드를 다시 확인해야 할 때 중요한 것은 '기능 추가'라는 유형이 아니라, '어떤 요구사항을 해결하기 위한 코드였는가'입니다. 따라서 우리는 모든 커밋 메시지를 <code>btsk-요구사항번호</code>로 시작하여 그 의도를 명확히 드러냅니다.</p>
            </div>
        </section>

        <section id="maintainers" class="content-section">
            <div class="card">
                <h3>Maintainers</h3>
                <p>
                    <a href="https://github.com/xqqldir"><img src="https://img.shields.io/badge/Github-xqqldir-yellow" alt="Static Badge"/></a>
                    <a href="https://github.com/Hyeonjun0527"><img src="https://img.shields.io/badge/Github-Hyeonjun0527-green" alt="Static Badge"/></a>
                    <a href="https://github.com/flareseek"><img src="https://img.shields.io/badge/Github-flareseek-orange" alt="Static Badge"/></a>
                </p>
            </div>
        </section>

        <section id="git-convention" class="content-section">
            <div class="card">
                <h3>Git 컨벤션</h3>
                
                <h4>브랜치 전략</h4>
                <p>우리 팀은 아래와 같은 GitFlow 기반의 브랜치 전략을 사용합니다.</p>
                <pre><code class="mermaid">
  gitGraph
  commit id: "init"
  branch develop
  checkout develop
  commit id: "dev init"
  branch author/btsk-80/feat-login
  commit id: "feat: login"
  checkout develop
  merge author/btsk-80/feat-login id: "btsk-80: 로그인 기능 구현"
  branch release/yyyy-mm-dd
  commit id: "snapshot"
  checkout develop
  commit id: "dev"
  branch refactor
  commit id: "refactor"
  checkout develop
  merge refactor id:"refactor merge"
  checkout main
  merge release/yyyy-mm-dd id:"release merge"
  checkout develop
                </code></pre>
                
                <h4>브랜치 종류</h4>
                <ul>
                    <li><code>main</code>: 배포 이력을 관리하는 브랜치입니다. (태그/릴리스 전용)</li>
                    <li><code>develop</code>: 모든 기능 브랜치가 통합되고 검증되는 통합 브랜치입니다.</li>
                    <li><code>release/yyyy-mm-dd</code>: 배포를 위한 스냅샷 브랜치입니다. 카카오 테크 캠퍼스 정책에 따라 `develop`의 내용을 `main`으로 반영할 때 사용하지만, 실제 서버 배포는 `develop` 브랜치를 기준으로 진행됩니다.</li>
                    <li><code>refactor/*</code>: 코드 리팩토링 전용 브랜치입니다.</li>
                    <li><code>author/요구사항번호/타입-요약</code>: 핵심 기능 개발 브랜치입니다. 요구사항 번호(예: btsk-80)를 반드시 포함해야 합니다. (예: <code>flareseek/btsk-80/feat-social-login</code>)</li>
                </ul>

                <h4>커밋 메시지</h4>
                <p>우리 팀의 커밋 메시지 규칙은 단순하지만 명확합니다. <strong><code>요구사항번호: 작업내용</code></strong> 형식을 따릅니다.</p>
                <blockquote>
                    <p><strong>왜 이 방식을 고수하는가?</strong><br>
                    <code>btsk-</code>가 포함된 커밋은 '해당 요구사항이 반영된, 잘 작동하는 서버'임을 보증하는 단위입니다. 만약 수백 개의 <code>feat</code>, <code>docs</code>, <code>style</code> 커밋이 섞여 있다면, 문제가 발생했을 때 어느 지점으로 돌아가야 할지 판단하기 매우 어렵습니다. 하지만 요구사항 번호로 커밋이 정리되어 있으면, 특정 기능이 추가되기 전의 안정적인 상태로 즉시 <code>reset</code>하는 것이 가능해집니다. 모든 커밋에 '추적 가능한 의도'를 부여하는 것이 핵심입니다.</p>
                </blockquote>
                <ul>
                    <li>좋은 예: <code>btsk-80: 소셜 로그인 기능 구현</code></li>
                    <li>나쁜 예: <del><code>로그인 기능 구현</code></del>, <del><code>feat: 로그인 기능</code></del></li>
                </ul>
                
                <table>
                    <thead>
                        <tr><th>Type</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>feat</strong></td><td>새로운 기능 추가</td></tr>
                        <tr><td><strong>fix</strong></td><td>버그 수정</td></tr>
                        <tr><td><strong>docs</strong></td><td>문서 수정</td></tr>
                        <tr><td><strong>style</strong></td><td>코드 스타일 변경 (들여쓰기, 세미콜론 등; 기능 변경 없음)</td></tr>
                        <tr><td><strong>refactor</strong></td><td>기능 변경 없는 코드 리팩토링</td></tr>
                        <tr><td><strong>test</strong></td><td>테스트 코드 추가 또는 수정</td></tr>
                        <tr><td><strong>chore</strong></td><td>빌드, 패키지 매니저 설정 등 (기타 잡일)</td></tr>
                        <tr><td><strong>hotfix</strong></td><td>급하게 배포해야 하는 치명적인 버그 수정</td></tr>
                    </tbody>
                </table>
                
                <h4>풀리퀘스트 (PR) 및 머지 방식</h4>
                <p>모든 작업 브랜치는 <code>develop</code> 브랜치로 PR(Pull Request)을 통해 머지됩니다.</p>
                <ul>
                    <li>PR 제목은 <code>요구사항번호: 작업내용</code> 형식으로 명확하게 작성합니다. (예: <code>btsk-80: 소셜 로그인 기능 구현</code>)</li>
                    <li>모든 PR은 최소 1명 이상의 팀원에게 리뷰 및 승인을 받아야 합니다.</li>
                    <li>PR을 머지할 때는 **Squash and Merge** 방식을 사용합니다. 이를 통해 작업 브랜치의 여러 커밋들이 PR 제목을 커밋 메시지로 하는 단일 커밋으로 합쳐져 <code>develop</code> 브랜치에 반영됩니다. 따라서 PR 제목을 컨벤션에 맞게 명확히 작성하는 것이 매우 중요합니다.</li>
                </ul>
            </div>
        </section>

        <section id="api-design" class="content-section">
            <div class="card">
                <h3>API 설계</h3>
                <h4>API 설계 및 버전 관리</h4>
                <p>API 엔드포인트는 RESTful 원칙을 따라 리소스 중심으로 설계하며, 명사는 복수형을 사용하고 동사 사용은 지양합니다.</p>
                <ul>
                    <li>좋은 예: <code>GET /users/{id}</code>, <code>POST /posts</code></li>
                    <li>나쁜 예: <del><code>GET /getUserInfo</code></del>, <del><code>POST /createNewPost</code></del></li>
                </ul>
                <p>API 버전 관리는 URL 경로에 <code>v1</code>, <code>v2</code> 등을 포함하여 명시적으로 관리합니다. (예: <code>/api/v1/users</code>)</p>

                <h4>API 응답 형식</h4>
                <p>API 응답은 HTTP 상태 코드를 적극적으로 활용하여 요청의 결과를 나타냅니다.</p>
                <ul>
                    <li><strong>성공 시 (2xx)</strong>: 요청이 성공적으로 처리되었을 경우, 응답 본문(Body)에는 순수한 데이터 객체(DTO)를 반환합니다. 별도의 래퍼(Wrapper) 객체로 감싸지 않습니다.</li>
                    <li><strong>실패 시 (4xx, 5xx)</strong>: 요청 처리 중 오류가 발생했을 경우, 명확한 HTTP 상태 코드와 함께 아래와 같이 일관된 형식의 에러 정보를 본문에 반환합니다.</li>
                </ul>
                <pre><code>
{
  "timestamp": "2025-08-20T10:30:00.123Z",
  "status": 404,
  "error": "Not Found",
  "code": "U001",
  "message": "해당 사용자를 찾을 수 없습니다.",
  "path": "/api/v1/users/999"
}
                </code></pre>
                
                <h4>에러 코드 명세</h4>
                <p>예측 가능한 비즈니스 예외 상황에 대해서는 별도의 에러 코드를 정의하여 사용합니다. 에러 코드는 도메인을 나타내는 알파벳과 숫자를 조합하여 <code>도메인코드+숫자</code> 형식으로 만듭니다. (예: U001 - User, P002 - Post)</p>
            </div>
        </section>

        <section id="build-deploy" class="content-section">
            <div class="card">
                <h3>빌드 및 배포 전략</h3>
                
                <h4>브랜치 별 역할</h4>
                <ul>
                    <li><code>develop</code>: 기능 개발이 완료되고 통합되는 브랜치입니다. CI/CD 파이프라인을 통해 이 브랜치의 최신 코드가 서버에 자동으로 배포됩니다.</li>
                    <li><code>main</code>: 주 1회 코드 리뷰와 승인 절차를 거쳐 병합되는 '안정 버전'을 관리하는 브랜치입니다.</li>
                </ul>

                <h4>현재 배포 상황 (2025.10.29 기준)</h4>
                <p>현재 저희 서비스는 실서비스를 목표로 운영되고 있으며, <strong><code>develop</code> 브랜치를 기준</strong>으로 운영 서버에 배포하고 있습니다. 이는 <code>main</code> 브랜치의 주 1회 리뷰 및 병합 주기보다 더 빠르게 개발 변경 사항을 사용자에게 제공하고 테스트하기 위함입니다. 본래 스테이징 서버로 사용하려던 환경을 현재의 운영 서버로 사용하고 있습니다.</p>
                <ul>
                    <li><strong>현재 운영 백엔드 서버 주소</strong>: <code>https://qa.api.pull.it.kr</code></li>
                    <li><strong>현재 서비스 주소</strong>: <code>https://pull.it.kr</code></li>
                </ul>

                <h4>향후 배포 계획</h4>
                <p>사용자 수가 증가하고 서비스가 더욱 안정화되어야 하는 시점이 오면, 별도의 운영 서버를 새로 개설할 계획입니다. 그때부터는 <code>main</code> 브랜치에 <code>vX.Y.Z</code> 형식의 태그(Tag)를 생성하는 것을 기준으로 새 운영 서버에 배포를 진행할 것입니다.</p>
                 <ul>
                    <li><strong>향후 운영 백엔드 서버 주소</strong>: <code>https://api.pull.it.kr</code> (현재는 사용되지 않음)</li>
                </ul>
                <p>자세한 서버 구축 및 배포 과정은 사이드바의 '배포 프로세스' 섹션을 참고해주세요.</p>
            </div>
        </section>

        <section id="deploy-overview" class="content-section">
            <div class="card">
                <h3>배포 개요: EC2 무빌드 배포 시스템</h3>
                <p>우리 팀은 **"EC2에서는 빌드하지 않고, 실행만 한다"**는 원칙을 따르는 '무빌드(No-Build) 배포 시스템'을 구축했습니다. 이 방식은 EC2 서버의 리소스를 절약하고, 배포 속도를 획기적으로 향상시키며, 보안을 강화하는 이점이 있습니다.</p>
                
                <h4>배포 흐름</h4>
                <pre><code>
로컬 환경: 빌드 담당 (무거운 작업)
     ↓
Docker Hub: 빌드된 이미지 저장소
     ↓
EC2 서버: 이미지 PULL 후 실행만 담당 (가벼운 작업)
                </code></pre>

                <h4>핵심 이점</h4>
                 <ul>
                    <li><strong>EC2 리소스 절약</strong>: 서버 내에서 직접 코드를 빌드하지 않으므로 CPU와 메모리 사용량을 최소화할 수 있습니다.</li>
                    <li><strong>배포 속도 향상</strong>: 이미 빌드된 Docker 이미지를 가져와 실행하기만 하면 되므로 배포 과정이 매우 빠릅니다.</li>
                    <li><strong>보안성 강화</strong>: EC2 서버에 JDK, Gradle 등 빌드와 관련된 도구를 설치할 필요가 없어 공격 노출 지점을 줄일 수 있습니다.</li>
                </ul>
            </div>
        </section>

        <section id="deploy-ec2-setup" class="content-section">
            <div class="card">
                <h3>1. EC2 서버 초기 설정</h3>
                <p>새로운 Ubuntu EC2 인스턴스를 생성한 후, 아래의 스크립트를 실행하여 개발 및 배포에 필요한 기본 환경을 자동으로 구성합니다. 이 스크립트는 Zsh, Oh My Zsh, Docker, Docker Compose 등을 설치하고 기본 설정을 완료합니다.</p>
                <h4>Ubuntu (EC2) 자동 설치/설정 스크립트</h4>
                <pre><code class="language-bash">
# ==== Ubuntu (EC2) 자동 설치/설정 스크립트 ====
set -euxo pipefail

# 0) 기본 패키지
sudo apt-get update
sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
  ca-certificates curl zsh git htop maven

# 1) Oh My Zsh 설치 (비대화형: RUNZSH/CHSH 막기)
export RUNZSH=no CHSH=no
sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"

# 2) 플러그인 설치
ZSH_CUSTOM="${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}"
mkdir -p "$ZSH_CUSTOM/plugins"
git clone --depth=1 https://github.com/zsh-users/zsh-autosuggestions "$ZSH_CUSTOM/plugins/zsh-autosuggestions" || true
git clone --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting "$ZSH_CUSTOM/plugins/zsh-syntax-highlighting" || true

# 3) .zshrc 자동 수정 (백업 후 plugins 라인 교체/추가)
cp ~/.zshrc{,.bak.$(date +%F_%T)}
if grep -qE '^\s*plugins=\(' ~/.zshrc; then
  sed -i -E 's/^\s*plugins=\(.*\)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting)/' ~/.zshrc
else
  printf '\n# Oh My Zsh plugins\nplugins=(git zsh-autosuggestions zsh-syntax-highlighting)\n' >> ~/.zshrc
fi

# 4) 비번 없이 기본 쉘을 zsh로 바꾸기 (sudo 사용)
command -v zsh >/dev/null
grep -q "$(command -v zsh)" /etc/shells || echo "$(command -v zsh)" | sudo tee -a /etc/shells >/dev/null
sudo chsh -s "$(command -v zsh)" "$USER"

# 4.5) (공식 문서) Docker apt 저장소 이용 설치
for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do
  sudo apt-get remove -y "$pkg" || true
done
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
sudo systemctl enable --now docker
sudo usermod -aG docker "$USER" || true

# 설치 확인 (재로그인 전이므로 sudo로 확인)
sudo docker --version
sudo docker compose version
sudo docker run --rm hello-world || true

# 5) 적용
exec zsh -l
                </code></pre>
            </div>
        </section>

        <section id="deploy-docker-build" class="content-section">
            <div class="card">
                <h3>2. Docker 빌드 전략 (Multi-stage & Cache)</h3>
                <p>Docker 이미지를 효율적으로 빌드하기 위해 **Multi-stage 빌드**와 **레이어 캐싱** 전략을 사용합니다.</p>
                
                <h4>Dockerfile 원리</h4>
                <p>Dockerfile은 두 단계(stage)로 구성됩니다.</p>
                <ol>
                    <li><strong>`builder` 스테이지</strong>: JDK와 Gradle이 포함된 환경에서 소스코드를 컴파일하여 실행 가능한 <code>.jar</code> 파일을 생성합니다.</li>
                    <li><strong>`runtime` 스테이지</strong>: 최소한의 JRE(Java Runtime Environment)만 포함된 가벼운 환경에, `builder` 스테이지에서 생성된 <code>.jar</code> 파일만 복사하여 최종 이미지를 만듭니다.</li>
                </ol>
                <p>이를 통해 최종 배포 이미지는 불필요한 빌드 도구 없이 오직 실행에 필요한 파일만 담게 되어 용량이 작고 보안에 유리합니다.</p>

                <h4>레이어 캐시를 활용한 빌드 속도 최적화</h4>
                <p>소스코드 변경이 잦다는 점을 고려하여, 변경 빈도가 낮은 의존성 관련 파일(<code>build.gradle</code>, <code>settings.gradle</code> 등)을 먼저 복사하고 의존성을 다운로드합니다. 소스코드(<code>src/</code>)는 가장 마지막에 복사합니다. 이렇게 하면 소스코드만 변경되었을 때, 이전 단계의 레이어 캐시를 그대로 재사용하여 의존성을 다시 다운로드하는 시간을 절약하고 빌드 속도를 크게 향상시킬 수 있습니다.</p>
                 <pre><code>
# Dockerfile 예시
# Stage 1: Build
FROM amazoncorretto:21-alpine-jdk AS builder
WORKDIR /app
COPY gradle/ gradle/
COPY gradlew build.gradle settings.gradle ./
RUN ./gradlew dependencies # 의존성 먼저 다운로드 (캐싱)
COPY src/ ./src/
RUN ./gradlew bootJar

# Stage 2: Runtime
FROM amazoncorretto:21-alpine
WORKDIR /app
COPY --from=builder /app/build/libs/*.jar ./app.jar
# ... (사용자 설정, 헬스체크 등)
ENTRYPOINT ["java", "-jar", "app.jar"]
                </code></pre>
            </div>
        </section>

        <section id="deploy-docker-compose" class="content-section">
            <div class="card">
                <h3>3. EC2에서 컨테이너 실행 (Docker Compose)</h3>
                <p>로컬에서 빌드하여 Docker Hub에 푸시한 이미지를 EC2 서버에서 가져와 실행합니다.</p>
                <h4>사전 준비 (로컬)</h4>
                <p>먼저 로컬 환경(WSL 등)에서 Docker Hub 사용자 이름 등 환경 변수를 설정합니다.</p>
                <pre><code class="language-bash">
export DOCKER_REGISTRY=your-dockerhub-username/pullit
export DB_PASSWORD=your_secure_db_password  
export DB_ROOT_PASSWORD=your_secure_root_password
                </code></pre>

                <h4>docker-compose-qa.yml</h4>
                <p>EC2 서버에 아래 내용으로 <code>docker-compose-qa.yml</code> 파일을 생성합니다. 이 파일은 Spring Boot 애플리케이션과 MariaDB 데이터베이스 컨테이너를 정의합니다.</p>
                <pre><code class="language-yaml">
services:
  pullit-qa-app:
    image: ${DOCKER_REGISTRY}:latest
    container_name: pullit-qa-app
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - DB_URL=jdbc:mariadb://pullit-qa-db:3306/pullit_qa?createDatabaseIfNotExist=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8
      - DB_USERNAME=pullit_qa
      - DB_PASSWORD=${DB_PASSWORD}
      - SPRING_PROFILES_ACTIVE=qa
      - JAVA_OPTS=-Xmx512m -Xms256m
    depends_on:
      pullit-qa-db:
        condition: service_healthy
    networks:
      - pullit-qa-network
    healthcheck:
      test: [ "CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health" ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 40s

  pullit-qa-db:
    image: mariadb:10.11
    container_name: pullit-qa-db
    restart: unless-stopped
    environment:
      - MARIADB_DATABASE=pullit_qa
      - MARIADB_USER=pullit_qa
      - MARIADB_PASSWORD=${DB_PASSWORD}
      - MARIADB_ROOT_PASSWORD=${DB_ROOT_PASSWORD}
    volumes:
      - pullit_qa_data:/var/lib/mysql
    networks:
      - pullit-qa-network
    healthcheck:
      test: [ "CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${DB_ROOT_PASSWORD}" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

volumes:
  pullit_qa_data:
    driver: local

networks:
  pullit-qa-network:
    driver: bridge
                </code></pre>
            </div>
        </section>

        <section id="deploy-dns" class="content-section">
            <div class="card">
                <h3>4. DNS 및 도메인 연결 (Route 53)</h3>
                <p>사용자가 EC2 인스턴스의 IP 주소 대신 기억하기 쉬운 도메인 이름(예: api-qa.pull.it.kr)으로 접속할 수 있도록 설정합니다.</p>
                <ol>
                    <li><strong>도메인 구매</strong>: 가비아와 같은 도메인 등록 기관에서 원하는 도메인을 구매합니다.</li>
                    <li><strong>Route 53 호스팅 영역 생성</strong>: AWS Route 53에서 구매한 도메인으로 호스팅 영역을 생성합니다.</li>
                    <li><strong>네임서버(NS) 변경</strong>: Route 53에서 제공하는 4개의 NS 레코드 값을 복사하여, 가비아의 도메인 설정에 네임서버 정보로 업데이트합니다. 이 과정을 통해 해당 도메인의 관리 권한이 Route 53으로 위임됩니다.</li>
                    <li><strong>A 레코드 생성</strong>: Route 53 호스팅 영역에서 레코드를 생성합니다. 레코드 유형은 'A'로 선택하고, 값에는 EC2 인스턴스의 퍼블릭 IP 주소를 입력합니다. (예: `api-qa.pull.it.kr` → `52.78.63.25`)</li>
                </ol>
            </div>
        </section>
        
        <section id="deploy-nginx" class="content-section">
            <div class="card">
                <h3>5. Nginx 리버스 프록시 설정</h3>
                <p>Nginx를 웹 서버로 사용하여 외부에서 들어오는 요청(80 포트)을 내부에서 실행 중인 Spring Boot 애플리케이션(8080 포트)으로 전달하는 리버스 프록시를 설정합니다.</p>
                <h4>Nginx 설치 및 실행</h4>
                <pre><code class="language-bash">
# Nginx 설치
sudo apt update -y
sudo apt install nginx -y

# Nginx 시작
sudo systemctl start nginx
                </code></pre>

                <h4>리버스 프록시 설정</h4>
                <p><code>/etc/nginx/conf.d/api-qa.pull.it.kr.conf</code> 파일을 생성하고 아래 내용을 작성합니다. 이 설정은 `api-qa.pull.it.kr` 도메인으로 들어오는 80 포트 요청을 내부 8080 포트로 전달합니다.</p>
                 <pre><code class="language-nginx">
upstream api_backend {
    server 127.0.0.1:8080;
    keepalive 32;
}

server {
    listen 80;
    server_name api-qa.pull.it.kr;

    location / {
        proxy_pass http://api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
                </code></pre>
                
                <h4>Nginx 재시작</h4>
                <p>설정 파일을 수정한 후에는 Nginx를 재시작하여 변경사항을 적용합니다. <code>reload</code>가 적용되지 않을 경우, <code>stop</code> 후 <code>start</code>를 시도해보는 것이 좋습니다.</p>
                 <pre><code class="language-bash">
sudo systemctl stop nginx
sudo systemctl start nginx
                </code></pre>
            </div>
        </section>

        <section id="deploy-https" class="content-section">
            <div class="card">
                <h3>6. HTTPS 적용 (Certbot)</h3>
                <p>Let's Encrypt의 무료 SSL/TLS 인증서를 발급받고 자동으로 갱신해주는 Certbot을 사용하여 도메인에 HTTPS를 적용합니다.</p>
                <h4>Certbot 설치 및 실행</h4>
                <pre><code class="language-bash">
# Certbot 및 Nginx 플러그인 설치
sudo apt install -y certbot python3-certbot-nginx

# Nginx 설정을 기반으로 인증서 발급 및 적용
sudo certbot --nginx -d api-qa.pull.it.kr
                </code></pre>
                <p>위 명령어를 실행하면, Certbot이 Nginx 설정 파일을 분석하여 `api-qa.pull.it.kr` 도메인에 대한 인증서를 발급하고, HTTP(80) 요청을 HTTPS(443)로 자동 리디렉션하도록 Nginx 설정을 자동으로 수정해줍니다.</p>
            </div>
        </section>

        <section id="code-convention" class="content-section">
            <div class="card">
                <h3>코딩 컨벤션</h3>
                <p>우리 팀의 모든 Java 코드는 <a href="https://google.github.io/styleguide/javaguide.html" target="_blank">Google Java Style Guide</a>를 따릅니다.</p>
                <p>모든 팀원은 아래의 개발 환경 설정을 통해 코드 스타일이 자동으로 적용되도록 해야 합니다.</p>
            </div>
        </section>

        <section id="environment-setup" class="content-section">
            <div class="card">
                <h3>개발 환경 설정 (IntelliJ 기준)</h3>
                <h4>Checkstyle</h4>
                <ol>
                    <li>Marketplace에서 <code>Checkstyle-IDEA</code> 플러그인을 설치합니다.</li>
                    <li>Settings > Tools > Checkstyle 로 이동합니다.</li>
                    <li>Configuration File 항목에서 '+' 버튼을 클릭합니다.</li>
                    <li>'Use a local check configuration file'을 선택하고, 프로젝트 내 <code>config/checkstyle/google_checks.xml</code> 파일을 선택합니다.</li>
                    <li>Description에 'Google Style - custom'을 입력하고 설정을 완료합니다.</li>
                </ol>

                <h4>Google Java Format</h4>
                <ol>
                    <li>Marketplace에서 <code>google-java-format</code> 플러그인을 설치합니다.</li>
                    <li><code>Help > Edit Custom VM Options</code> 메뉴를 엽니다.</li>
                    <li>기존 내용 하단에 아래 내용을 추가합니다.</li>
                </ol>
                <pre><code>
--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED
--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED
--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED
--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED
--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED
--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
                </code></pre>
                <p><em>참조: <a href="https://github.com/google/google-java-format/blob/master/README.md#intellij-jre-config" target="_blank">Official Guide</a></em></p>
            </div>
        </section>

        <section id="team-resources" class="content-section">
            <div class="card">
                <h3>팀 프로젝트 페이지</h3>
                <p>우리 팀의 모든 프로젝트 관리와 문서화는 아래 Notion 페이지를 중심으로 이루어집니다.</p>
                <p><a href="https://www.notion.so/pullit/2-245c61d733498000a869fc6fb977d52e?p=255c61d733498052b394fe84e3dbc1e0&pm=s" target="_blank">강원대 2팀 프로젝트 페이지 바로가기</a></p>
                <p>이 페이지에서는 다음의 정보들을 확인할 수 있습니다.</p>
                <ul>
                    <li><strong>캘린더 및 칸반 보드</strong>: 팀의 전체 일정을 관리하고, 주차별 목표와 진행 상황을 시각적으로 파악할 수 있습니다.</li>
                    <li><strong>To-Do-List 및 목표</strong>: 스프린트별 상세 과제와 목표를 관리하는 공간입니다.</li>
                    <li><strong>설계 문서</strong>: 화면 설계, API 명세, 요구사항 정의서 등 프로젝트의 핵심 설계 자산이 모두 모여있습니다.</li>
                    <li><strong>스프린트 백로그</strong>: Jira와 유사한 형태로, 각 백엔드 작업(BTSK-XX)의 담당자, 상태, 진행 주차 등을 상세하게 추적하고 관리합니다.</li>
                    <li><strong>기술 블로그</strong>: 개발 과정에서 발생한 이슈 해결 경험, 새로운 기술 학습 내용 등 팀의 기술적 자산을 축적하는 공간입니다.</li>
                </ul>
            </div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const navLinks = document.querySelectorAll('.nav-link');
            const contentSections = document.querySelectorAll('.content-section');
            const defaultSectionId = '#introduction';
            const dropdownToggles = document.querySelectorAll('.dropdown-toggle');

            // Dropdown toggle functionality
            dropdownToggles.forEach(toggle => {
                toggle.addEventListener('click', function(event) {
                    event.stopPropagation();
                    // Close other open dropdowns
                    document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                        if (menu !== this.nextElementSibling) {
                            menu.classList.remove('show');
                        }
                    });
                    this.nextElementSibling.classList.toggle('show');
                });
            });

            // Close dropdowns if clicking outside
            window.addEventListener('click', function(event) {
                if (!event.target.matches('.dropdown-toggle')) {
                    document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                        menu.classList.remove('show');
                    });
                }
            });

            function showSection(hash) {
                let sectionToShow = document.querySelector(hash);
                if (!sectionToShow) {
                    sectionToShow = document.querySelector(defaultSectionId);
                    history.replaceState(null, null, ' '); // Use empty state instead of hash
                }

                contentSections.forEach(section => {
                    section.classList.remove('active');
                });
                
                sectionToShow.classList.add('active');
                
                // Close dropdowns after selection
                document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
            
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    // Only prevent default for internal links
                    if (this.getAttribute('href').startsWith('#')) {
                        e.preventDefault();
                        const targetId = this.getAttribute('href');
                        // Use replaceState to avoid cluttering history with hash changes
                        history.replaceState(null, null, targetId);
                        showSection(targetId);
                    }
                });
            });

            window.addEventListener('popstate', () => {
                showSection(location.hash || defaultSectionId);
            });
            
            showSection(location.hash || defaultSectionId);
        });

        // Add toggle functionality for floating controls
        const toggleBtn = document.getElementById('toggle-controls');
        const controlsContent = document.querySelector('.controls-content');

        toggleBtn.addEventListener('click', () => {
            controlsContent.classList.toggle('hidden');
            if (controlsContent.classList.contains('hidden')) {
                toggleBtn.textContent = '🔽';
            } else {
                toggleBtn.textContent = '🔼';
            }
        });
    </script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
</body>
</html>
